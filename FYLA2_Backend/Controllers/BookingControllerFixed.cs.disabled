using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using FYLA2_Backend.Data;
using FYLA2_Backend.Models;
using FYLA2_Backend.DTOs;
using System.Security.Claims;

namespace FYLA2_Backend.Controllers
{
  [ApiController]
  [Route("api/[controller]")]
  [Authorize]
  public class BookingControllerFixed : ControllerBase
  {
    private readonly ApplicationDbContext _context;
    private readonly ILogger<BookingControllerFixed> _logger;

    public BookingControllerFixed(ApplicationDbContext context, ILogger<BookingControllerFixed> logger)
    {
      _context = context;
      _logger = logger;
    }

    private string GetUserId()
    {
      return User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();
    }

    [HttpGet("available-slots")]
    public async Task<ActionResult<List<TimeSlotDto>>> GetAvailableSlots(
        [FromQuery] string providerId,
        [FromQuery] int serviceId,
        [FromQuery] string date)
    {
      try
      {
        if (!DateTime.TryParse(date, out var requestDate))
        {
          return BadRequest("Invalid date format");
        }

        // Get service details
        var service = await _context.Services
            .FirstOrDefaultAsync(s => s.Id == serviceId);

        if (service == null)
        {
          return NotFound("Service not found");
        }

        // Get existing bookings for the day
        var existingBookings = await _context.Bookings
            .Where(b => b.ProviderId == providerId &&
                       b.BookingDate.Date == requestDate.Date &&
                       b.Status != BookingStatus.Cancelled)
            .ToListAsync();

        // Generate time slots (9 AM to 6 PM, 30-minute intervals)
        var timeSlots = new List<TimeSlotDto>();
        var startHour = 9;
        var endHour = 18;
        var intervalMinutes = 30;

        for (int hour = startHour; hour < endHour; hour++)
        {
          for (int minute = 0; minute < 60; minute += intervalMinutes)
          {
            var slotTime = new DateTime(requestDate.Year, requestDate.Month, requestDate.Day, hour, minute, 0);
            var slotEndTime = slotTime.AddMinutes(service.Duration);

            // Check if slot conflicts with existing bookings
            bool isAvailable = !existingBookings.Any(b =>
                (slotTime >= b.StartTime && slotTime < b.EndTime) ||
                (slotEndTime > b.StartTime && slotEndTime <= b.EndTime) ||
                (slotTime <= b.StartTime && slotEndTime >= b.EndTime));

            timeSlots.Add(new TimeSlotDto
            {
              StartTime = slotTime,
              EndTime = slotEndTime,
              IsAvailable = isAvailable
            });
          }
        }

        return Ok(timeSlots);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex, "Error getting available slots");
        return StatusCode(500, new { error = "Failed to get available slots", details = ex.Message });
      }
    }

    [HttpPost("create")]
    public async Task<ActionResult<BookingDto>> CreateBooking([FromBody] CreateBookingDto request)
    {
      try
      {
        var userId = GetUserId();

        // Validate service
        var service = await _context.Services
            .Include(s => s.Provider)
            .FirstOrDefaultAsync(s => s.Id == request.ServiceId);

        if (service == null)
        {
          return NotFound("Service not found");
        }

        // Check for conflicts
        var existingBooking = await _context.Bookings
            .FirstOrDefaultAsync(b => b.ProviderId == service.ProviderId &&
                                    b.BookingDate.Date == request.BookingDate.Date &&
                                    ((request.StartTime >= b.StartTime && request.StartTime < b.EndTime) ||
                                     (request.EndTime > b.StartTime && request.EndTime <= b.EndTime)) &&
                                    b.Status != BookingStatus.Cancelled);

        if (existingBooking != null)
        {
          return BadRequest("Time slot is not available");
        }

        var booking = new Booking
        {
          ClientId = userId,
          ProviderId = service.ProviderId,
          ServiceId = request.ServiceId,
          BookingDate = request.BookingDate,
          StartTime = request.StartTime,
          EndTime = request.EndTime,
          TotalPrice = service.Price,
          Status = BookingStatus.Pending,
          Notes = request.Notes,
          PaymentMethod = request.PaymentMethod
        };

        _context.Bookings.Add(booking);
        await _context.SaveChangesAsync();

        var bookingDto = new BookingDto
        {
          Id = booking.Id,
          ClientId = booking.ClientId,
          ProviderId = booking.ProviderId,
          ServiceId = booking.ServiceId,
          BookingDate = booking.BookingDate,
          StartTime = booking.StartTime,
          EndTime = booking.EndTime,
          Status = booking.Status.ToString(),
          TotalPrice = booking.TotalPrice,
          Notes = booking.Notes,
          DurationMinutes = booking.DurationMinutes,
          PaymentMethod = booking.PaymentMethod
        };

        return CreatedAtAction(nameof(GetBooking), new { id = booking.Id }, bookingDto);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex, "Error creating booking");
        return StatusCode(500, new { error = "Failed to create booking", details = ex.Message });
      }
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<BookingDto>> GetBooking(int id)
    {
      try
      {
        var booking = await _context.Bookings
            .Include(b => b.Client)
            .Include(b => b.Provider)
            .Include(b => b.Service)
            .FirstOrDefaultAsync(b => b.Id == id);

        if (booking == null)
        {
          return NotFound();
        }

        var bookingDto = new BookingDto
        {
          Id = booking.Id,
          ClientId = booking.ClientId,
          ProviderId = booking.ProviderId,
          ServiceId = booking.ServiceId,
          BookingDate = booking.BookingDate,
          StartTime = booking.StartTime,
          EndTime = booking.EndTime,
          Status = booking.Status.ToString(),
          TotalPrice = booking.TotalPrice,
          Notes = booking.Notes,
          DurationMinutes = booking.DurationMinutes,
          PaymentMethod = booking.PaymentMethod
        };

        return Ok(bookingDto);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex, "Error getting booking");
        return StatusCode(500, new { error = "Failed to get booking", details = ex.Message });
      }
    }

    [HttpGet("user")]
    public async Task<ActionResult<List<BookingDto>>> GetUserBookings()
    {
      try
      {
        var userId = GetUserId();

        var bookings = await _context.Bookings
            .Include(b => b.Client)
            .Include(b => b.Provider)
            .Include(b => b.Service)
            .Where(b => b.ClientId == userId || b.ProviderId == userId)
            .OrderByDescending(b => b.BookingDate)
            .ToListAsync();

        var bookingDtos = bookings.Select(booking => new BookingDto
        {
          Id = booking.Id,
          ClientId = booking.ClientId,
          ProviderId = booking.ProviderId,
          ServiceId = booking.ServiceId,
          BookingDate = booking.BookingDate,
          StartTime = booking.StartTime,
          EndTime = booking.EndTime,
          Status = booking.Status.ToString(),
          TotalPrice = booking.TotalPrice,
          Notes = booking.Notes,
          DurationMinutes = booking.DurationMinutes,
          PaymentMethod = booking.PaymentMethod
        }).ToList();

        return Ok(bookingDtos);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex, "Error getting user bookings");
        return StatusCode(500, new { error = "Failed to get user bookings", details = ex.Message });
      }
    }

    [HttpPut("{id}/status")]
    public async Task<ActionResult> UpdateBookingStatus(int id, [FromBody] UpdateBookingStatusDto request)
    {
      try
      {
        var userId = GetUserId();
        var booking = await _context.Bookings.FirstOrDefaultAsync(b => b.Id == id);

        if (booking == null)
        {
          return NotFound();
        }

        // Only provider or client can update status
        if (booking.ProviderId != userId && booking.ClientId != userId)
        {
          return Forbid();
        }

        if (Enum.TryParse<BookingStatus>(request.Status, out var status))
        {
          booking.Status = status;
          booking.UpdatedAt = DateTime.UtcNow;

          await _context.SaveChangesAsync();
          return Ok();
        }

        return BadRequest("Invalid status");
      }
      catch (Exception ex)
      {
        _logger.LogError(ex, "Error updating booking status");
        return StatusCode(500, new { error = "Failed to update booking status", details = ex.Message });
      }
    }
  }
}
