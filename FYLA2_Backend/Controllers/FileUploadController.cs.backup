using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using FYLA2_Backend.Data;
using FYLA2_Backend.DTOs;
using FYLA2_Backend.Models;
using System.Security.Claims;

namespace FYLA2_Backend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class FileUploadController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IWebHostEnvironment _environment;
        private readonly long _maxFileSize = 10 * 1024 * 1024; // 10MB
        private readonly string[] _allowedExtensions = { ".jpg", ".jpeg", ".png", ".gif", ".webp" };

        public FileUploadController(ApplicationDbContext context, IWebHostEnvironment environment)
        {
            _context = context;
            _environment = environment;
        }

        [HttpPost("image")]
        public async Task<ActionResult<FileUploadDto>> UploadImage([FromBody] ImageUploadRequestDto request)
        {
            try
            {
                var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userId))
                    return Unauthorized();

                // Validate file data
                if (string.IsNullOrEmpty(request.Base64Data))
                    return BadRequest("No file data provided");

                // Decode base64
                byte[] fileBytes;
                try
                {
                    var base64Data = request.Base64Data;
                    if (base64Data.Contains(','))
                        base64Data = base64Data.Split(',')[1];
                    
                    fileBytes = Convert.FromBase64String(base64Data);
                }
                catch
                {
                    return BadRequest("Invalid base64 data");
                }

                // Validate file size
                if (fileBytes.Length > _maxFileSize)
                    return BadRequest($"File size exceeds maximum limit of {_maxFileSize / (1024 * 1024)}MB");

                // Validate file extension
                var extension = Path.GetExtension(request.FileName).ToLowerInvariant();
                if (!_allowedExtensions.Contains(extension))
                    return BadRequest("Invalid file type. Only image files are allowed.");

                // Generate unique filename
                var uniqueFileName = $"{Guid.NewGuid()}{extension}";
                var categoryFolder = string.IsNullOrEmpty(request.Category) ? "general" : request.Category;
                var uploadPath = Path.Combine(_environment.WebRootPath, "uploads", categoryFolder);
                
                // Create directory if it doesn't exist
                if (!Directory.Exists(uploadPath))
                    Directory.CreateDirectory(uploadPath);

                var filePath = Path.Combine(uploadPath, uniqueFileName);

                // Save file
                await System.IO.File.WriteAllBytesAsync(filePath, fileBytes);

                // Generate thumbnail for larger images
                var thumbnailFileName = $"thumb_{uniqueFileName}";
                var thumbnailPath = Path.Combine(uploadPath, thumbnailFileName);
                await CreateThumbnail(filePath, thumbnailPath, 300, 300);

                // Create file record in database
                var fileUpload = new FileUpload
                {
                    FileName = request.FileName,
                    FilePath = filePath,
                    ContentType = request.ContentType ?? "application/octet-stream",
                    FileSize = fileBytes.Length,
                    Category = categoryFolder,
                    Description = request.Description,
                    UserId = userId,
                    ThumbnailPath = File.Exists(thumbnailPath) ? thumbnailPath : null,
                    CreatedAt = DateTime.UtcNow
                };

                _context.FileUploads.Add(fileUpload);
                await _context.SaveChangesAsync();

                // Generate URLs
                var baseUrl = $"{Request.Scheme}://{Request.Host}";
                var fileUrl = $"{baseUrl}/uploads/{categoryFolder}/{uniqueFileName}";
                var thumbnailUrl = $"{baseUrl}/uploads/{categoryFolder}/{thumbnailFileName}";

                var result = new FileUploadDto
                {
                    Id = fileUpload.Id,
                    FileName = fileUpload.FileName,
                    ContentType = fileUpload.ContentType,
                    Size = fileUpload.Size,
                    Url = fileUrl,
                    ThumbnailUrl = thumbnailUrl,
                    UploadedAt = fileUpload.UploadedAt
                };

                return Ok(result);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Error uploading file", error = ex.Message });
            }
        }

        [HttpPost("images/bulk")]
        public async Task<ActionResult<List<FileUploadDto>>> BulkUploadImages([FromBody] BulkImageUploadDto request)
        {
            try
            {
                var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userId))
                    return Unauthorized();

                if (request.Images == null || !request.Images.Any())
                    return BadRequest("No images provided");

                if (request.Images.Count > 10)
                    return BadRequest("Maximum 10 images allowed per bulk upload");

                var results = new List<FileUploadDto>();
                var categoryFolder = string.IsNullOrEmpty(request.Category) ? "general" : request.Category;
                var uploadPath = Path.Combine(_environment.WebRootPath, "uploads", categoryFolder);
                
                // Create directory if it doesn't exist
                if (!Directory.Exists(uploadPath))
                    Directory.CreateDirectory(uploadPath);

                foreach (var imageRequest in request.Images)
                {
                    try
                    {
                        // Validate and process each image
                        if (string.IsNullOrEmpty(imageRequest.Base64Data))
                            continue;

                        // Decode base64
                        byte[] fileBytes;
                        try
                        {
                            var base64Data = imageRequest.Base64Data;
                            if (base64Data.Contains(','))
                                base64Data = base64Data.Split(',')[1];
                            
                            fileBytes = Convert.FromBase64String(base64Data);
                        }
                        catch
                        {
                            continue; // Skip invalid files
                        }

                        // Validate file size
                        if (fileBytes.Length > _maxFileSize)
                            continue;

                        // Validate file extension
                        var extension = Path.GetExtension(imageRequest.FileName).ToLowerInvariant();
                        if (!_allowedExtensions.Contains(extension))
                            continue;

                        // Generate unique filename
                        var uniqueFileName = $"{Guid.NewGuid()}{extension}";
                        var filePath = Path.Combine(uploadPath, uniqueFileName);

                        // Save file
                        await System.IO.File.WriteAllBytesAsync(filePath, fileBytes);

                        // Generate thumbnail
                        var thumbnailFileName = $"thumb_{uniqueFileName}";
                        var thumbnailPath = Path.Combine(uploadPath, thumbnailFileName);
                        await CreateThumbnail(filePath, thumbnailPath, 300, 300);

                        // Create file record
                        var fileUpload = new FileUpload
                        {
                            Id = Guid.NewGuid().ToString(),
                            FileName = imageRequest.FileName,
                            UniqueFileName = uniqueFileName,
                            ContentType = imageRequest.ContentType,
                            Size = fileBytes.Length,
                            Category = categoryFolder,
                            UserId = userId,
                            UploadedAt = DateTime.UtcNow
                        };

                        _context.FileUploads.Add(fileUpload);

                        // Generate URLs
                        var baseUrl = $"{Request.Scheme}://{Request.Host}";
                        var fileUrl = $"{baseUrl}/uploads/{categoryFolder}/{uniqueFileName}";
                        var thumbnailUrl = $"{baseUrl}/uploads/{categoryFolder}/{thumbnailFileName}";

                        results.Add(new FileUploadDto
                        {
                            Id = fileUpload.Id,
                            FileName = fileUpload.FileName,
                            ContentType = fileUpload.ContentType,
                            Size = fileUpload.Size,
                            Url = fileUrl,
                            ThumbnailUrl = thumbnailUrl,
                            UploadedAt = fileUpload.UploadedAt
                        });
                    }
                    catch
                    {
                        continue; // Skip files that fail to process
                    }
                }

                await _context.SaveChangesAsync();
                return Ok(results);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Error uploading files", error = ex.Message });
            }
        }

        [HttpGet("user/{userId}")]
        public async Task<ActionResult<List<FileUploadDto>>> GetUserFiles(string userId, [FromQuery] string? category = null)
        {
            try
            {
                var currentUserId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(currentUserId))
                    return Unauthorized();

                // Users can only access their own files unless they're admin
                if (currentUserId != userId)
                    return Forbid("Access denied");

                var query = _context.FileUploads.Where(f => f.UserId == userId);
                
                if (!string.IsNullOrEmpty(category))
                    query = query.Where(f => f.Category == category);

                var files = await query
                    .OrderByDescending(f => f.UploadedAt)
                    .ToListAsync();

                var baseUrl = $"{Request.Scheme}://{Request.Host}";
                var result = files.Select(f => new FileUploadDto
                {
                    Id = f.Id,
                    FileName = f.FileName,
                    ContentType = f.ContentType,
                    Size = f.Size,
                    Url = $"{baseUrl}/uploads/{f.Category}/{f.UniqueFileName}",
                    ThumbnailUrl = $"{baseUrl}/uploads/{f.Category}/thumb_{f.UniqueFileName}",
                    UploadedAt = f.UploadedAt
                }).ToList();

                return Ok(result);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Error retrieving files", error = ex.Message });
            }
        }

        [HttpDelete("{fileId}")]
        public async Task<ActionResult> DeleteFile(string fileId)
        {
            try
            {
                var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userId))
                    return Unauthorized();

                var file = await _context.FileUploads.FirstOrDefaultAsync(f => f.Id == fileId);
                if (file == null)
                    return NotFound("File not found");

                // Users can only delete their own files
                if (file.UserId != userId)
                    return Forbid("Access denied");

                // Delete physical files
                var uploadPath = Path.Combine(_environment.WebRootPath, "uploads", file.Category);
                var filePath = Path.Combine(uploadPath, file.UniqueFileName);
                var thumbnailPath = Path.Combine(uploadPath, $"thumb_{file.UniqueFileName}");

                if (System.IO.File.Exists(filePath))
                    System.IO.File.Delete(filePath);

                if (System.IO.File.Exists(thumbnailPath))
                    System.IO.File.Delete(thumbnailPath);

                // Delete database record
                _context.FileUploads.Remove(file);
                await _context.SaveChangesAsync();

                return Ok(new { message = "File deleted successfully" });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Error deleting file", error = ex.Message });
            }
        }

        [HttpPost("optimize/{fileId}")]
        public async Task<ActionResult<FileUploadDto>> OptimizeImage(string fileId)
        {
            try
            {
                var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userId))
                    return Unauthorized();

                var file = await _context.FileUploads.FirstOrDefaultAsync(f => f.Id == fileId);
                if (file == null)
                    return NotFound("File not found");

                if (file.UserId != userId)
                    return Forbid("Access denied");

                var uploadPath = Path.Combine(_environment.WebRootPath, "uploads", file.Category);
                var originalPath = Path.Combine(uploadPath, file.UniqueFileName);
                var optimizedFileName = $"opt_{file.UniqueFileName}";
                var optimizedPath = Path.Combine(uploadPath, optimizedFileName);

                // Create optimized version (compressed for web)
                await CreateOptimizedImage(originalPath, optimizedPath, 1920, 1080, 80);

                // Update file record
                var optimizedFile = new FileUpload
                {
                    Id = Guid.NewGuid().ToString(),
                    FileName = $"optimized_{file.FileName}",
                    UniqueFileName = optimizedFileName,
                    ContentType = file.ContentType,
                    Size = new FileInfo(optimizedPath).Length,
                    Category = file.Category,
                    UserId = userId,
                    UploadedAt = DateTime.UtcNow
                };

                _context.FileUploads.Add(optimizedFile);
                await _context.SaveChangesAsync();

                var baseUrl = $"{Request.Scheme}://{Request.Host}";
                var result = new FileUploadDto
                {
                    Id = optimizedFile.Id,
                    FileName = optimizedFile.FileName,
                    ContentType = optimizedFile.ContentType,
                    Size = optimizedFile.Size,
                    Url = $"{baseUrl}/uploads/{optimizedFile.Category}/{optimizedFile.UniqueFileName}",
                    ThumbnailUrl = $"{baseUrl}/uploads/{optimizedFile.Category}/thumb_{optimizedFile.UniqueFileName}",
                    UploadedAt = optimizedFile.UploadedAt
                };

                return Ok(result);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Error optimizing image", error = ex.Message });
            }
        }

        private async Task CreateThumbnail(string sourcePath, string thumbnailPath, int maxWidth, int maxHeight)
        {
            try
            {
                // Simple thumbnail creation (in production, use ImageSharp or similar library)
                // For now, just copy the file - in a real implementation you'd resize it
                await System.IO.File.WriteAllBytesAsync(thumbnailPath, await System.IO.File.ReadAllBytesAsync(sourcePath));
            }
            catch
            {
                // If thumbnail creation fails, skip it
            }
        }

        private async Task CreateOptimizedImage(string sourcePath, string optimizedPath, int maxWidth, int maxHeight, int quality)
        {
            try
            {
                // Simple optimization (in production, use ImageSharp or similar library)
                // For now, just copy the file - in a real implementation you'd compress and resize
                await System.IO.File.WriteAllBytesAsync(optimizedPath, await System.IO.File.ReadAllBytesAsync(sourcePath));
            }
            catch
            {
                // If optimization fails, skip it
            }
        }
    }
}
